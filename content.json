{"pages":[{"title":"关于","text":"一个愿意学习改变未来的程序员,寻找突破，工作生活痛并快乐着","link":"/about/index.html"}],"posts":[{"title":"Leetcode1-两数之和","text":"题目Leetcode towsum 题目，题号 1 题解暴力破解js 版本1234567891011121314151617181920/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) { let map = new Map(); for(let i in nums) { map.set(nums[i], i); } for(let i in nums) { // let exist = target -nums[i]; if(map.has(target -nums[i]) &amp;&amp; map.get(target-nums[i]) &gt; i) { return [i, map.get(target - nums[i])] } } return [0, -1]}; java版本123456789101112131415class Solution { public int[] twoSum(int[] nums, int target) { int len = nums.length; for(int i = 0; i &lt; len; i++) { for(int j = i+1; j &lt; len; j++) { if(nums[i] + nums[j] == target) { return new int[] {i, j}; } } } return new int[0]; }} 使用mapjs版本12345678910111213141516171819/** * @param {number[]} nums * @param {number} target * @return {number[]} */var twoSum = function(nums, target) { let map = new Map(); for(let i in nums) { map.set(nums[i], i); } for(let i in nums) { let exist = target -nums[i]; if(map.has(exist) &amp;&amp; map.get(exist) &gt; i) { return [i, map.get(exist)] } } return [0, -1]}; java版本12345678910111213class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; hashmap = new HashMap&lt;Integer, Integer&gt;(); for( int i =0; i &lt; nums.length; i++) { if(hashmap.containsKey(target - nums[i])) { return new int[]{i, hashmap.get(target - nums[i])}; } hashmap.put(nums[i], i); } return new int[0]; }}","link":"/2021/02/04/Leetcode1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"Leetcode351:两个数组交集","text":"题目给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 题解 使用hashmap javascript 版本123456789101112131415161718192021222324252627282930/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersect = function(nums1, nums2) { let res = []; let map1 = new Map(); let map2 = new Map(); for(let item of nums1) { if(!map1.has(item)) map1.set(item, 0) map1.set(item, map1.get(item) + 1) } for(let item of nums2) { if(!map2.has(item)) map2.set(item, 0) map2.set(item, map2.get(item) + 1) } for(let item of map1.keys()) { if(map2.has(item)) { let key1num = map1.get(item); let key2num = map2.get(item); let num = key1num; if(key1num &gt; key2num ) num = key2num; for(var i = 0; i &lt; num; i++) res.push(item) } } return res;}; 上面的方法，使用了多余一个map，空间占比比较大 更新1234567891011121314151617181920212223242526/** * @param {number[]} nums1 * @param {number[]} nums2 * @return {number[]} */var intersect = function(nums1, nums2) { if(nums1.length &gt; nums2.length) return intersect(nums2, nums1) let res = []; let map = new Map(); for(let item of nums1) { if(!map.has(item)) map.set(item, 0) map.set(item, map.get(item) + 1) } for(let item of nums2) { let count = map.get(item) || 0; if(count &gt; 0) { res.push(item); --count; map.set(item, count) if(count &lt;=0) map.delete(item) } } return res;};","link":"/2021/02/05/Leetcode351-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BA%A4%E9%9B%86/"},{"title":"Window上Redis替代方案-Memurai","text":"Redis 替代方案Redis 早已经不支持windows，现在github上的windows版本的redis早已经是多年前的版本。现在有了redis的替代方案，完全兼容Redis, 可以按照redis的操作来使用。 官网地址 https://www.memurai.com/ 连接使用我们使用Redis GUI 工具连接 连接操作跟Redis一样。","link":"/2021/01/27/RedisOnWindows/"},{"title":"Redis分布式锁","text":"分布式锁加锁Redis 对资源加锁，使用 setnx 指令，表示 set if not exists,比如 setnx lock:key 200 ，就对 lock:key 加锁了。 过期时间setnx 对资源已经加锁，如果不执行 del 命令，则资源不会释放，会陷入死锁，解决办法是对锁资源加上过期时间 1expire lock:key 5 # 表示资源过期时间为5s 上面两个命令，是分两步操作，不是原子命令操作，如果 expire 操作没有执行，又会陷入死锁 Redis方案官方方案原子操作 12set lock:key 200 ex 5 nx 其中nodejs 方案 1234567891011const Redis = require('ioredis');const redis = new Redis({ port: 6379, // Redis port host: '127.0.0.1', // Redis host family: 4, // 4 (IPv4) or 6 (IPv6) password: 'abcd1234', db: 0,});redis.set('lock:key', 200, 'EX', 10, 'NX'); 超时问题线程A 获取了锁，设置时间10s，然后执行30s任务。 待A开始执行10s后，锁资源超时，被Redis释放。 此时 线程B来获取锁，系统没有，因此获得锁资源，此时系统中存在两个线程对同一锁资源都获取到了，得到执行任务，锁的独享性不存在了。同时，在B执行任务过程中，A执行完毕，执行 删除锁操作，则B占有的锁，被A 释放了。 解决方案可以设置 lock:key 的 value 值为独有的值，当要删除的 value 与 redis中的 value 一致时，才允许删除操作 1234567891011let tag = Math.floor(Math.random() * 1000);redis.set(`lock:key`, tag, 'EX', 10, 'NX')..........let value = redis.get(`lock:key`)if(value ==== tag) redis.del(`lock:key`) 注意，上面的操作也不是原子性的，需要使用Lua 脚本来执行操作 12345678const script = `if redis.call(&quot;get&quot;, KEYS[1] == ARGV[1] then return redis.call(&quot;del&quot;, KEYS[1])) else return 0 end`;redis.eval(script, 1, `lock:key`, tag); 执行上面的代码来释放锁 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980'use strict';const Redis = require('ioredis');const sleep = require('mz-modules/sleep');const redis = new Redis({ port: 6379, // Redis port host: '127.0.0.1', // Redis host family: 4, // 4 (IPv4) or 6 (IPv6) password: 'abcd1234', db: 0,});class RedisLock { constructor(options) { this.expireMode = options.expireMode || 'EX'; // 过期时间策略 this.setMode = options.setMode || 'NX'; // 锁策略 this.expire = options.expire || 5; // 默认过期时间 this.maxtime = options.maxtime || 10; // 加锁重试时间最大值 } /** * lock key * @param {string} key key to lock * @param {string} value value to set * @param {number} expire key expire time * @param {number} startTime 加锁开始时间 */ async lock(key, value, expire, startTime = Date.now()) { const result = await redis.set(key, value, this.expireMode, expire, this.setMode); if (result === 'OK') { console.log(`${key} ${value} 加锁成功`); return true; } // 如果加锁等待超时后，仍然不成功，停止加锁 if ((Date.now() - startTime) &gt; this.maxtime) { console.log(`${key} ${value} 加锁失败，不再加锁`); return false; } // 加锁不成功等待重试 await sleep(3000); return this.lock(key, value, expire); } /** * 解锁操作 * @param {string} key key * @param {string} value value */ async unlock(key, value) { const script = `if redis.call(&quot;get&quot;, KEYS[1] == ARGV[1] then return redis.call(&quot;del&quot;, KEYS[1])) else return 0 end`; try { const result = redis.eval(script, 1, key, value); if (result === 1) return true; return false; } catch (error) { console.log(`解锁 ${key} ${value}失败`); return false; } }}const redislock = new RedisLock();async function testlock(name) { const value = Math.floor(Math.random() * 10000); await redislock.lock(name, value); await sleep(3000); // 解锁 await redis.unlock(name, value);}testlock('name1');testlock('name2');","link":"/2021/01/27/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"动手去做","text":"技能提升阅读各种资料、书籍、文章，只是让你懂得更多，并不会让你提高技能。只有通过练习（practice）才能提高技能。如果你想变得更好，那就去动手做。 – Jason Fried（Basecamp 的创始人） 感悟只看不做只能让知识停留在脑中，容易忘记，技能不能提升。自工作以来，看过太多文章，学过很多技术，目前真正掌握使用的，只是其中一小部分，书到用时方恨少的局面常常遇到。","link":"/2021/01/03/%E5%8A%A8%E6%89%8B%E5%8E%BB%E5%81%9A/"}],"tags":[{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"格言","slug":"格言","link":"/tags/%E6%A0%BC%E8%A8%80/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"知识学习","slug":"知识学习","link":"/categories/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"},{"name":"技术","slug":"知识学习/技术","link":"/categories/%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/%E6%8A%80%E6%9C%AF/"}]}